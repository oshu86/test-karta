<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>index – Interaktiv karta (mobiloptimerad v3.2)</title>
<!-- JSZip för ZIP‑export -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
  :root { --bg:#0f1115; --ink:#e6e6e6; --muted:#2a3142; --panel:#141822; --shadow: rgba(0,0,0,.45); --accent:#ffd166; --line:#7dd3fc; --vh: 1vh; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow: hidden; }

  /* Stage / world */
  #stage { position: relative; width: 100vw; height: calc(var(--vh) * 100); overflow: hidden; touch-action: none; }
  #world { position: absolute; left: 0; top: 0; transform-origin: 0 0; will-change: transform; }
  #map { display:block; user-select: none; -webkit-user-drag: none; pointer-events: none; max-width: none; }

  /* Markörer */
  .marker { position: absolute; width: 32px; height: 32px; transform: translate(-50%, -100%); cursor: pointer;
            background-image: url('ikonkarta.png'); background-size: contain; background-position:center; background-repeat:no-repeat; }
  .marker.open { background-image: url('ikonkarta2.png'); filter: drop-shadow(0 0 6px var(--accent)); }

  /* Desktop-sidopanel */
  #sidebar { position: fixed; left: 0; top: 0; height: 100dvh; width: 360px; max-width: 90vw; background: rgba(20,24,34,.96);
             border-right: 1px solid var(--muted); box-shadow: 0 6px 20px var(--shadow); z-index: 30; display: none; }
  #sidebar header { display:flex; align-items:center; justify-content: space-between; gap:8px; padding:10px 12px; border-bottom:1px solid #262c3b; }
  #sidebar h3 { margin:0; font-size:16px; font-weight:600; opacity:.9; }
  .mini { border:1px solid var(--muted); background:#1a2030; color:#ddd; padding:6px 10px; border-radius:8px; cursor:pointer; }
  #content { height: calc(100dvh - 52px); overflow:auto; padding:12px; }
  #noteBody { background:#0e1220; border:1px solid #2a3142; border-radius:8px; padding:10px; min-height: 180px; white-space: pre-wrap; outline:none; word-break: break-word; overflow-wrap: anywhere; }
  #noteBody:focus { box-shadow: inset 0 0 0 2px #3b82f6; }
  .note-img { max-width: 100%; height: auto; display:block; margin:8px 0; border-radius:6px; border:1px solid #2a3142; cursor: zoom-in; }

  /* Lightbox */
  #lightbox { position: fixed; inset: 0; background: rgba(0,0,0,.92); display: none; align-items: center; justify-content: center; z-index: 100; touch-action: none; }
  #lightboxInner { position: relative; max-width: 96vw; max-height: 96vh; overflow: hidden; }
  #lightboxImg { display:block; max-width: none; user-select: none; -webkit-user-drag: none; transform-origin: 0 0; will-change: transform; }
  #lightboxClose { position: fixed; right: 14px; top: calc(env(safe-area-inset-top) + 10px); background: rgba(0,0,0,.55); color:#fff; border:1px solid rgba(255,255,255,.2); border-radius: 10px; padding: 8px 10px; z-index: 110; cursor:pointer; }

  /* Overlay SVG för mätning */
  #overlay { position:absolute; left:0; top:0; overflow:visible; pointer-events:none; }
  .measure-line { stroke: var(--line); stroke-width: 2; fill: none; vector-effect: non-scaling-stroke; }
  .measure-label { font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; fill: #e6e6e6; paint-order: stroke; stroke: rgba(0,0,0,.6); stroke-width: 3; }

  /* Verktygsrad – horisontellt uppe till höger */
  #toolbox { position: fixed; right: 8px; top: env(safe-area-inset-top, 8px); display: flex; gap: 8px; z-index: 60; align-items:center; flex-wrap: nowrap; }
  .toolbtn { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:8px 10px; border-radius:10px; cursor:pointer; font-size:14px; white-space: nowrap; }
  .toolbtn.active { outline: 2px solid #60a5fa; }

  /* Skallinje */
  #scalebar { position: fixed; left: 14px; bottom: calc(14px + env(safe-area-inset-bottom)); z-index: 70; color:#e5e7eb; font-size: 12px; }
  #scalebar .bar { height: 6px; background: #e5e7eb; border-radius: 3px; box-shadow: 0 1px 0 rgba(0,0,0,.35) inset; }
  #scalebar .label { margin-top: 6px; text-align: center; opacity: .9; }

  #playerBanner { display:none; }

  @media (max-width: 820px) {
    .toolbtn { padding:6px 8px; font-size:12px; }
    #sidebar { display:none !important; }
  }

  /* Bottenskiva (mobil-notiser) */
  #sheet { position: fixed; left: 0; right: 0; bottom: 0; z-index: 90; display:none; }
  #sheetPanel { margin: 0 auto; max-width: 880px; background: rgba(20,24,34,.98); border-top-left-radius: 16px; border-top-right-radius: 16px; border:1px solid #2a3142; box-shadow: 0 -8px 24px rgba(0,0,0,.45); padding: 6px 12px 14px; transform: translateY(0); will-change: transform; touch-action: pan-y; }
  #sheetHeader { display:flex; align-items:center; justify-content: space-between; gap:8px; padding-bottom:8px; border-bottom:1px solid #262c3b; position: relative; touch-action: none; }
  /* Tre streck som handtag (explicit mål) */
  #sheetHandle { width: 48px; height: 14px; display:flex; flex-direction: column; gap:3px; align-items:center; justify-content:center; margin: 0 auto 8px; touch-action: none; }
  #sheetHandle span { width: 36px; height: 3px; background:#3b4154; border-radius: 2px; opacity:.95; }

  #sheetBody { max-height: 48dvh; overflow:auto; -webkit-overflow-scrolling: touch; white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; }
  .mini-ghost { background:transparent; border:1px solid #374151; color:#e5e7eb; padding:6px 10px; border-radius:10px; cursor:pointer; }

  /* Begränsa radlängd i notiser (≈51 tecken) */
  .note-text { max-width: 51ch; }
</style>
</head>
<body>
  <aside id="sidebar">
    <header>
      <h3 id="sidebarTitle">Markering</h3>
      <div id="editorBtns">
        <button id="addImg" class="mini" type="button" title="Lägg till bild">+ Bild</button>
        <input id="imgInput" type="file" accept="image/*" style="display:none" />
      </div>
    </header>
    <div id="content">
      <div id="noteBody" class="note-text" contenteditable="true" spellcheck="true" lang="sv">Skriv din not här...</div>
      <p id="pasteHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: Klistra in (Ctrl/Cmd+V) eller dra‑och‑släpp en bild direkt i textfältet. Klicka på en bild för stor visning.</p>
    </div>
  </aside>

  <!-- Mobil-bottenskiva -->
  <div id="sheet">
    <div id="sheetPanel">
      <div id="sheetHandle" title="Dra upp för full, ner för stäng">
        <span></span><span></span><span></span>
      </div>
      <div id="sheetHeader">
        <h3 id="sheetTitle" style="margin:0;font-size:15px">Markering</h3>
        <div id="sheetBtns">
          <button id="mAddImg" class="mini-ghost" type="button" title="Lägg till bild">+ Bild</button>
          <button id="sheetClose" class="mini-ghost" type="button" title="Stäng">Stäng</button>
          <input id="mImgInput" type="file" accept="image/*" style="display:none" />
        </div>
      </div>
      <div id="sheetBody" class="note-text" contenteditable="true" spellcheck="true" lang="sv"></div>
      <p id="sheetHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: dra på de tre strecken för att expandera/stänga.</p>
    </div>
  </div>

  <div id="toolbox">
    <button id="btnModeNotes" class="toolbtn active" title="Skapa/hantera notiser">Läge: Notiser</button>
    <button id="btnModeMeasure" class="toolbtn" title="Mät avstånd">Mät</button>
    <button id="btnUndo" class="toolbtn" title="Ångra senaste mätpunkt">Ångra</button>
    <button id="btnReset" class="toolbtn" title="Ny mätning">Ny mätning</button>
    <button id="btnExport" class="toolbtn" title="Exportera ZIP (data.json + images)">Export</button>
  </div>

  <div id="playerBanner">Player‑läge (read‑only) – läser data.json</div>

  <div id="scalebar">
    <div class="bar" id="sbBar" style="width:120px"></div>
    <div class="label" id="sbLabel">—</div>
  </div>

  <div id="stage">
    <div id="world">
      <img id="map" src="Tyraal.webp" alt="Tyraal-karta" />
      <svg id="overlay"></svg>
    </div>
  </div>

  <div id="lightbox">
    <button id="lightboxClose" type="button">Stäng</button>
    <div id="lightboxInner">
      <img id="lightboxImg" alt="" />
    </div>
  </div>

<script>
(function(){
  // ======= Export‑parametrar =======
  const WEBP_QUALITY = 0.8;        // 0..1
  const MAX_IMG_EDGE = 2560;        // px – längsta sida

  // ===== Stabil 100vh på mobiler =====
  const setVH = () => document.documentElement.style.setProperty('--vh', (visualViewport ? visualViewport.height : window.innerHeight) * 0.01 + 'px');
  setVH(); if (window.visualViewport){ visualViewport.addEventListener('resize', setVH); } else { window.addEventListener('resize', setVH); }

  const IS_PLAYER = (location.hash === '#player') || (new URLSearchParams(location.search).get('mode') === 'player');
  const IS_MOBILE = matchMedia('(max-width: 820px)').matches;

  // ===== SKALA =====
  const METERS_PER_PIXEL = 250000 / 1073.6; // ≈ 232.77 m/px
  const MAP_WIDTH = 8192, MAP_HEIGHT = 5462; // fallback
  let metersPerPixelOverride = NaN; 
  const getMetersPerPixel = () => (isNaN(metersPerPixelOverride) ? METERS_PER_PIXEL : metersPerPixelOverride);

  // ===== DOM =====
  const stage = document.getElementById('stage');
  const world = document.getElementById('world');
  const map = document.getElementById('map');
  const overlay = document.getElementById('overlay');
  const sidebar = document.getElementById('sidebar');
  const sidebarTitle = document.getElementById('sidebarTitle');
  const editorBtns = document.getElementById('editorBtns');
  const noteBody = document.getElementById('noteBody');
  const pasteHint = document.getElementById('pasteHint');
  const addImgBtn = document.getElementById('addImg');
  const imgInput = document.getElementById('imgInput');
  const mAddImgBtn = document.getElementById('mAddImg');
  const mImgInput = document.getElementById('mImgInput');
  const sheet = document.getElementById('sheet');
  const sheetPanel = document.getElementById('sheetPanel');
  const sheetBody = document.getElementById('sheetBody');
  const sheetTitle = document.getElementById('sheetTitle');
  const sheetClose = document.getElementById('sheetClose');
  const sheetHint = document.getElementById('sheetHint');
  const sheetHandle = document.getElementById('sheetHandle');
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');
  const lightboxInner = document.getElementById('lightboxInner');
  const lightboxClose = document.getElementById('lightboxClose');
  const btnModeNotes = document.getElementById('btnModeNotes');
  const btnModeMeasure = document.getElementById('btnModeMeasure');
  const btnUndo = document.getElementById('btnUndo');
  const btnReset = document.getElementById('btnReset');
  const btnExport = document.getElementById('btnExport');
  const sbBar = document.getElementById('sbBar');
  const sbLabel = document.getElementById('sbLabel');

  // ===== Kamera =====
  let scale = 1, MIN = 1, MAX = 24, startScale = 1; 
  let tx = 0, ty = 0, imgW = 0, imgH = 0;

  function getPanBounds(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w = imgW * scale, h = imgH * scale;
    const centerX = (vw - w) / 2, centerY = (vh - h) / 2;
    if (w <= vw && h <= vh) return { minTx:centerX, maxTx:centerX, minTy:centerY, maxTy:centerY };
    if (w <= vw) return { minTx:centerX, maxTx:centerX, minTy: Math.min(0, vh - h), maxTy: 0 };
    if (h <= vh) return { minTx: Math.min(0, vw - w), maxTx: 0, minTy:centerY, maxTy:centerY };
    return { minTx: Math.min(0, vw - w), maxTx: 0, minTy: Math.min(0, vh - h), maxTy: 0 };
  }
  const clamp = (v,a,b) => Math.min(b, Math.max(a,v));
  function clampPan(){ const b = getPanBounds(); tx = clamp(tx, b.minTx, b.maxTx); ty = clamp(ty, b.minTy, b.maxTy); }

  function applyTransform(){
    world.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    world.querySelectorAll('.marker').forEach(el => { el.style.transform = `translate(-50%, -100%) scale(${1/scale})`; });
    overlay.setAttribute('width', imgW); overlay.setAttribute('height', imgH);
    updateScaleBar();
  }

  function zoomAt(screenX, screenY, factor){
    const rect = stage.getBoundingClientRect();
    const x = screenX - rect.left; const y = screenY - rect.top;
    const wx = (x - tx) / scale; const wy = (y - ty) / scale;
    const ns = clamp(scale * factor, MIN, MAX);
    tx = x - wx * ns; ty = y - wy * ns; scale = ns; clampPan(); applyTransform();
  }

  function fitToScreenAndCenter(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w0 = map.naturalWidth || MAP_WIDTH; const h0 = map.naturalHeight || MAP_HEIGHT;
    imgW = w0; imgH = h0;
    const s = Math.min(vw / imgW, vh / imgH);
    startScale = s; scale = s; 
    MIN = startScale * 0.98;  
    const w = imgW * scale, h = imgH * scale;
    tx = (vw - w)/2; ty = (vh - h)/2; applyTransform();
  }

  // — Mus-hjul zoom
  stage.addEventListener('wheel', e => { e.preventDefault(); const f = e.deltaY < 0 ? 1.15 : 1/1.15; zoomAt(e.clientX, e.clientY, f); }, {passive:false});

  // — Pointers (touch + mus)
  const pointers = new Map(); // id -> {x,y}
  let lastDist = null;
  let leftPan = false; // vänster-pan på tom yta
  let rightPan = false; // höger-pan var som helst
  let panStart = null;  // {x,y,tx,ty}

  stage.addEventListener('pointerdown', e => {
    const onMarker = !!e.target.closest('.marker');
    if (e.pointerType === 'mouse' && e.button === 2){
      rightPan = true; panStart = { x: e.clientX, y: e.clientY, tx, ty };
      window.addEventListener('contextmenu', ev => ev.preventDefault(), { once:true });
      stage.setPointerCapture(e.pointerId);
    }
    if (e.pointerType === 'mouse' && e.button === 0 && !onMarker){
      leftPan = true; panStart = { x: e.clientX, y: e.clientY, tx, ty };
      stage.setPointerCapture(e.pointerId);
    }
    if (e.pointerType !== 'mouse'){
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      stage.setPointerCapture(e.pointerId);
    }
  });

  stage.addEventListener('pointermove', e => {
    if (e.pointerType !== 'mouse' && pointers.has(e.pointerId)){
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      const pts = [...pointers.values()];
      if (pts.length === 1 && !leftPan && !rightPan){
        const p = pts[0];
        if (!panStart) panStart = { x: e.clientX, y: e.clientY, tx, ty };
        tx = panStart.tx + (p.x - panStart.x);
        ty = panStart.ty + (p.y - panStart.y);
        clampPan(); applyTransform();
        return;
      }
      if (pts.length === 2){
        const [a,b] = pts; const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2; const dist = Math.hypot(b.x-a.x, b.y-a.y);
        if (lastDist==null) { lastDist = dist; return; }
        const factor = dist / lastDist; lastDist = dist; zoomAt(midX, midY, factor);
        return;
      }
    }

    if ((leftPan || rightPan) && panStart){
      const p = { x: e.clientX, y: e.clientY };
      tx = panStart.tx + (p.x - panStart.x);
      ty = panStart.ty + (p.y - panStart.y);
      clampPan(); applyTransform();
    }
  });

  function endPointer(e){
    if (e.pointerType !== 'mouse'){
      pointers.delete(e.pointerId);
      if (pointers.size < 2) lastDist = null;
      if (pointers.size === 0) panStart = null;
    }
    if (e.pointerType === 'mouse'){
      if (leftPan || rightPan) stage.releasePointerCapture?.(e.pointerId);
      leftPan = false; rightPan = false; panStart = null;
    }
  }
  stage.addEventListener('pointerup', endPointer);
  stage.addEventListener('pointercancel', endPointer);

  // ===== Lagring (IndexedDB + localStorage) =====
  const LSK = 'tyraal_markers_meta_v25';
  const DB_NAME = 'tyraal_db'; const DB_STORE = 'notes';
  let db = null;
  function openDB(){ return new Promise((resolve, reject) => { const req = indexedDB.open(DB_NAME, 1); req.onupgradeneeded = () => { db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' }); }; req.onsuccess = () => { db = req.result; resolve(db); }; req.onerror = () => reject(req.error); }); }
  function idbGet(id){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readonly'); const st = tx.objectStore(DB_STORE); const r = st.get(id); r.onsuccess = () => resolve(r.result?.html || ''); r.onerror = () => reject(r.error); }); }
  function idbSet(id, html){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readwrite'); const st = tx.objectStore(DB_STORE); const r = st.put({ id, html }); r.onsuccess = () => resolve(); r.onerror = () => reject(r.error); }); }
  function idbBulkGet(ids){ return Promise.all(ids.map(id => idbGet(id).then(html => ({ id, html })))); }
  function saveMeta(){ if (IS_PLAYER) return; const out = [...world.querySelectorAll('.marker')].map(m => ({ id: m.dataset.id, x: parseFloat(m.style.left), y: parseFloat(m.style.top) })); try { localStorage.setItem(LSK, JSON.stringify(out)); } catch(e){} }
  async function saveHTML(id, html){ if (IS_PLAYER) return; try { await idbSet(id, html); } catch(e){} }
  async function loadAllFromLocal(){ const meta = JSON.parse(localStorage.getItem(LSK) || '[]'); meta.forEach(o => createMarker(o.x, o.y, o.id, false)); const htmls = await idbBulkGet(meta.map(m => m.id)); htmls.forEach(({id, html}) => { store[id] = { html: html || '' }; }); }

  // ===== Player: data.json =====
  async function loadAllFromJSON(){
    try {
      const res = await fetch('data.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Kunde inte läsa data.json');
      const data = await res.json();
      if (typeof data.metersPerPixel === 'number' && isFinite(data.metersPerPixel)) metersPerPixelOverride = data.metersPerPixel;
      if (Array.isArray(data.markers)){
        data.markers.forEach(m => { createMarker(m.x, m.y, m.id, false); store[m.id] = { html: m.html || '' }; });
      }
    } catch (err){ console.error(err); alert('Kunde inte ladda spelardata (data.json).'); }
  }

  // ===== Per‑markör cache =====
  const store = {}; let openId = null;

  // ===== Bildinmatning (inbäddade data-URLer) =====
  let inserting = false, handlersBound = false;
  function fileToDataURL(file){ return new Promise((resolve, reject) => { const r=new FileReader(); r.onload=()=>resolve(r.result); r.onerror=reject; r.readAsDataURL(file); }); }
  async function insertImagesFromFiles(targetEl, files){
    if (inserting) return; inserting = true;
    try {
      for (const f of files){ if (!f || !f.type || !f.type.startsWith('image/')) continue; const data = await fileToDataURL(f); const img = document.createElement('img'); img.className = 'note-img'; img.src = data; attachImageClick(img); targetEl.appendChild(img); }
      if (openId){ const html = (IS_MOBILE ? sheetBody.innerHTML : noteBody.innerHTML); store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }
    } finally { inserting = false; }
  }
  function attachImageClick(img){ img.addEventListener('click', e => { e.stopPropagation(); openLightbox(img.src); }); }

  function bindOnce(){ if (handlersBound) return; handlersBound = true; if (!IS_PLAYER){
      addImgBtn?.addEventListener('click', () => { imgInput.value=''; imgInput.click(); });
      imgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(noteBody, files); imgInput.value=''; });
      mAddImgBtn?.addEventListener('click', () => { mImgInput.value=''; mImgInput.click(); });
      mImgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(sheetBody, files); mImgInput.value=''; });
      const pasteHandler = async (e, target) => { const items = e.clipboardData?.items || []; const files = []; for (const it of items){ if (it.kind==='file' && it.type.startsWith('image/')) files.push(it.getAsFile()); } if (files.length){ e.preventDefault(); e.stopPropagation(); if (!inserting) await insertImagesFromFiles(target, files); } };
      noteBody?.addEventListener('paste', e => pasteHandler(e, noteBody));
      sheetBody?.addEventListener('paste', e => pasteHandler(e, sheetBody));
      const inputHandler = async (target) => { if(openId){ const html = target.innerHTML; store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }}
      noteBody?.addEventListener('input', () => inputHandler(noteBody));
      sheetBody?.addEventListener('input', () => inputHandler(sheetBody));
    }
  }

  // ===== Lightbox (egen pan/zoom, isolerad) =====
  let lbOpen = false; let lbScale = 1; let lbTx = 0; let lbTy = 0; let lbImgW = 0; let lbImgH = 0; let lbStart = null; let lbLastDist = null; const LB_MIN = 1, LB_MAX = 8;

  function openLightbox(src){
    lightboxImg.onload = () => {
      lbImgW = lightboxImg.naturalWidth; lbImgH = lightboxImg.naturalHeight;
      const box = lightboxInner.getBoundingClientRect();
      const s = Math.min(box.width / lbImgW, box.height / lbImgH);
      lbScale = s; lbTx = (box.width - lbImgW * s)/2; lbTy = (box.height - lbImgH * s)/2;
      applyLightboxTransform();
    };
    lightboxImg.src = src;
    lightbox.style.display = 'flex'; lbOpen = true; lbStart = null; lbLastDist = null;
  }
  function closeLightbox(){ lbOpen = false; lightbox.style.display = 'none'; lightboxImg.src = ''; }
  lightbox.addEventListener('click', (e) => { if (e.target === lightbox) closeLightbox(); });
  lightboxClose.addEventListener('click', closeLightbox);

  function applyLightboxTransform(){ lightboxImg.style.transform = `translate(${lbTx}px, ${lbTy}px) scale(${lbScale})`; }
  function lbClampPan(){ const box = lightboxInner.getBoundingClientRect(); const w = lbImgW * lbScale, h = lbImgH * lbScale; const minX = Math.min(0, box.width - w), maxX = Math.max(0, (box.width - w)); const minY = Math.min(0, box.height - h), maxY = Math.max(0, (box.height - h)); lbTx = clamp(lbTx, minX, maxX); lbTy = clamp(lbTy, minY, maxY); }
  function lbZoomAt(cx, cy, factor){ const box = lightboxInner.getBoundingClientRect(); const x = cx - box.left; const y = cy - box.top; const wx = (x - lbTx) / lbScale; const wy = (y - lbTy) / lbScale; const ns = clamp(lbScale * factor, LB_MIN, LB_MAX); lbTx = x - wx * ns; lbTy = y - wy * ns; lbScale = ns; lbClampPan(); applyLightboxTransform(); }
  ['pointerdown','pointermove','pointerup','pointercancel','wheel','dblclick'].forEach(evt => { lightbox.addEventListener(evt, e => { e.stopPropagation(); if (evt !== 'pointerup' && evt !== 'pointercancel') e.preventDefault(); }, { passive:false }); });
  const lbPtrs = new Map(); lightbox.addEventListener('pointerdown', e => { if (!lbOpen) return; lightbox.setPointerCapture(e.pointerId); lbPtrs.set(e.pointerId, {x:e.clientX, y:e.clientY}); if (!lbStart) lbStart = { x:e.clientX, y:e.clientY, tx:lbTx, ty:lbTy }; });
  lightbox.addEventListener('pointermove', e => { if (!lbOpen || !lbPtrs.has(e.pointerId)) return; lbPtrs.set(e.pointerId, {x:e.clientX, y:e.clientY}); const pts = [...lbPtrs.values()]; if (pts.length === 1){ const p = pts[0]; if (!lbStart) lbStart = { x:e.clientX, y:e.clientY, tx:lbTx, ty:lbTy }; lbTx = lbStart.tx + (p.x - lbStart.x); lbTy = lbStart.ty + (p.y - lbStart.y); lbClampPan(); applyLightboxTransform(); } else if (pts.length === 2){ const [a,b] = pts; const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2; const dist=Math.hypot(b.x-a.x,b.y-a.y); if (lbLastDist==null){ lbLastDist = dist; return; } const factor = dist / lbLastDist; lbLastDist = dist; lbZoomAt(midX, midY, factor); } });
  function lbEnd(e){ lbPtrs.delete(e.pointerId); if (lbPtrs.size < 2) lbLastDist=null; if (lbPtrs.size===0) lbStart=null; }
  lightbox.addEventListener('pointerup', lbEnd); lightbox.addEventListener('pointercancel', lbEnd);
  lightbox.addEventListener('wheel', e => { if (!lbOpen) return; const f = e.deltaY < 0 ? 1.12 : 1/1.12; lbZoomAt(e.clientX, e.clientY, f); });
  lightbox.addEventListener('dblclick', e => { if (!lbOpen) return; lbZoomAt(e.clientX, e.clientY, 1.4); });

  // ===== Markörer (PC): klick öppnar, Alt/Shift + drag flyttar =====
  function uid(){ return Math.random().toString(36).slice(2,9); }
  function clientToWorldXY(x,y){ const rect = stage.getBoundingClientRect(); const cx = x - rect.left; const cy = y - rect.top; return { wx: (cx - tx) / scale, wy: (cy - ty) / scale }; }

  stage.addEventListener('dblclick', e => {
    if (mode !== 'notes' || IS_PLAYER) return;
    if (e.target.closest('.marker') || e.target.closest('#sidebar') || e.target.closest('#sheet')) return;
    e.preventDefault();
    const { wx, wy } = clientToWorldXY(e.clientX, e.clientY);
    const id = uid(); store[id] = { html: 'Skriv din not här...' };
    createMarker(wx, wy, id, true); openMarker(id);
  }, { passive:false });

  function createMarker(wx, wy, id, saveNow=true){
    if (!isFinite(wx) || !isFinite(wy)) return null;
    const m = document.createElement('div'); m.className = 'marker'; m.dataset.id = id; m.style.left = wx + 'px'; m.style.top = wy + 'px';

    let dragging = false, canDrag = false, startX=0, startY=0;
    const DRAG_THRESHOLD = 5; // px
    let suppressNextClick = false;

    m.addEventListener('click', ev => {
      if (suppressNextClick) { suppressNextClick = false; return; }
      ev.stopPropagation();
      if (openId === id) closePanels(); else openMarker(id);
    });

    m.addEventListener('pointerdown', ev => {
      if (mode !== 'notes' || IS_PLAYER) return;
      if (ev.pointerType==='mouse' && ev.button!==0) return; // bara vänster
      canDrag = ev.altKey || ev.shiftKey; dragging = false;
      startX = ev.clientX; startY = ev.clientY;
      if (canDrag){ document.body.classList.add('grabbing'); stage.classList.add('grabbing'); m.setPointerCapture(ev.pointerId); }
      ev.stopPropagation();
    });
    m.addEventListener('pointermove', ev => {
      if (!canDrag) return;
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      if (!dragging && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) dragging = true;
      if (dragging){ const { wx, wy } = clientToWorldXY(ev.clientX, ev.clientY); m.style.left = wx + 'px'; m.style.top  = wy + 'px'; }
    });
    m.addEventListener('pointerup', ev => {
      if (dragging){ suppressNextClick = true; saveMeta(); }
      dragging = false; canDrag = false; document.body.classList.remove('grabbing'); stage.classList.remove('grabbing');
    });

    m.addEventListener('contextmenu', async ev => { if (IS_PLAYER) return; ev.preventDefault(); if (confirm('Ta bort denna markering och dess notis?')) { if (openId === id) closePanels(); world.removeChild(m); delete store[id]; saveMeta(); try { await idbSet(id, ''); } catch(_){} } });

    world.appendChild(m);
    if (saveNow) saveMeta();
    return m;
  }

  function openMarker(id){
    if (openId && openId !== id){ const prev = world.querySelector(`.marker[data-id="${openId}"]`); if (prev) prev.classList.remove('open'); }
    openId = id; const marker = world.querySelector(`.marker[data-id="${id}"]`); if (marker) marker.classList.add('open');
    const html = store[id]?.html;
    const render = (h) => {
      if (IS_MOBILE){
        sheetTitle.textContent = 'Markering ' + id; sheet.style.display = 'block';
        sheetBody.innerHTML = h; sheetBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        sheetHint.style.display = IS_PLAYER ? 'none' : 'block';
        openSheet('half');
      } else {
        sidebarTitle.textContent = 'Markering ' + id; sidebar.style.display = 'block';
        noteBody.innerHTML = h; noteBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        pasteHint.style.display = IS_PLAYER ? 'none' : 'block';
      }
      (IS_MOBILE ? sheetBody : noteBody).querySelectorAll('img').forEach(img => attachImageClick(img));
      bindOnce();
      (IS_MOBILE ? null : editorBtns).style.display = IS_PLAYER ? 'none' : 'flex';
    };
    if (typeof html !== 'string'){ idbGet(id).then(h => { store[id] = { html: h || 'Skriv din not här...' }; render(store[id].html); }); }
    else render(html || 'Skriv din not här...');
  }

  function closePanels(){
    sidebar.style.display = 'none';
    sheet.style.display = 'none';
    const prev = openId ? world.querySelector(`.marker[data-id="${openId}"]`) : null;
    if (prev) prev.classList.remove('open');
    openId = null;
  }

  // Klick på tom karta stänger panel
  stage.addEventListener('click', e => {
    if (mode !== 'notes') return;
    if (e.target.closest('.marker')) return; // låt marker‑klick sköta sig
    closePanels();
  });

  // ===== Bottenskiva: tre-streckshandtag – korrekt pointer capture & iOS touch-action =====
  let mode = 'notes';
  let sheetState = 'half'; // 'closed' | 'half' | 'full'
  let sheetOffsetY = 0; // nuvarande translateY i px

  function sizes(){
    const vh = (visualViewport ? visualViewport.height : window.innerHeight);
    return { half: Math.round(vh * 0.50), full: Math.round(vh * 0.97), header: 74 };
  }
  function applySheetTransform(offset){ sheetOffsetY = offset; sheetPanel.style.transform = `translateY(${Math.max(0, offset)}px)`; }
  function setSheetHeight(state, animate=true){
    sheetState = state; const S = sizes(); const h = state==='full' ? S.full : (state==='half' ? S.half : 0);
    sheetBody.style.maxHeight = (state==='full' ? (S.full - S.header) : (S.half - S.header)) + 'px';
    if (animate) sheetPanel.style.transition = 'transform 140ms ease-out';
    applySheetTransform(state==='closed' ? (h+40) : 0);
    if (state==='closed') { closePanels(); } else { sheet.style.display = 'block'; }
    if (animate) setTimeout(()=>{ sheetPanel.style.transition = 'none'; }, 150);
  }
  function openSheet(state='half'){ sheet.style.display = 'block'; setSheetHeight(state); }

  let dragStartY = 0, dragStartTime = 0, draggingSheet = false, baseOffset = 0, dragTargetEl = null;
  function sheetDragStart(e){ draggingSheet = true; dragTargetEl = e.currentTarget; dragStartY = e.clientY; dragStartTime = performance.now(); baseOffset = sheetOffsetY; try { dragTargetEl.setPointerCapture(e.pointerId); } catch(_){} e.preventDefault(); }
  function sheetDragMove(e){ if (!draggingSheet) return; const dy = e.clientY - dragStartY; const S = sizes(); const upAllowance = -60; const newOffset = clamp(baseOffset + dy, upAllowance, S.full); sheetPanel.style.transition = 'none'; applySheetTransform(newOffset); }
  function sheetDragEnd(e){ if (!draggingSheet) return; try { dragTargetEl?.releasePointerCapture?.(e.pointerId); } catch(_){} draggingSheet = false; const dy = e.clientY - dragStartY; const dt = Math.max(1, performance.now() - dragStartTime); const vy = dy / dt; if (dy < -10 || vy < -0.3) { setSheetHeight('full'); return; } if (dy > 10 || vy > 0.5) { setSheetHeight('closed'); return; } setSheetHeight(sheetState); }

  ;[sheetHandle, document.getElementById('sheetHeader')].forEach(el => {
    el.addEventListener('pointerdown', sheetDragStart, { passive:false });
    el.addEventListener('pointermove', sheetDragMove, { passive:false });
    el.addEventListener('pointerup', sheetDragEnd);
    el.addEventListener('pointercancel', sheetDragEnd);
  });

  // Inaktivera zoom/pan inne i panelen
  ['pointermove','wheel','dblclick','gesturestart','gesturechange','gestureend'].forEach(evt => {
    sheetPanel.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }, { passive:false });
  });

  // Stäng-knapp stänger notis helt
  sheetClose.addEventListener('click', () => setSheetHeight('closed'));

  // ===== MÄTNING med etikett i mitten =====
  let measurePoints = []; let measurePath = null; let measureLabel = null;
  function setMode(newMode){ mode = newMode; btnModeNotes.classList.toggle('active', mode==='notes'); btnModeMeasure.classList.toggle('active', mode==='measure'); if (mode==='measure') closePanels(); if (mode==='notes') { clearMeasurePreview(); } }
  btnModeNotes.addEventListener('click', () => setMode('notes'));
  btnModeMeasure.addEventListener('click', () => setMode('measure'));
  btnUndo.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints.pop(); updateMeasurePath(); });
  btnReset.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints = []; updateMeasurePath(); });

  function clearMeasurePreview(){ if (measureLabel){ measureLabel.remove(); measureLabel = null; } }

  const formatMeters = m => (m < 1000) ? Math.round(m) + ' m' : (m/1000).toFixed(2) + ' km';
  function totalPixels(){ let totalPx = 0; for (let i=1;i<measurePoints.length;i++){ const a=measurePoints[i-1], b=measurePoints[i]; totalPx += Math.hypot(b.x-a.x, b.y-a.y); } return totalPx; }

  function updateMeasurePath(){
    if (!measurePoints.length){ if (measurePath) { measurePath.remove(); measurePath=null; } clearMeasurePreview(); return; }
    const d = measurePoints.map((p,i)=> (i? 'L':'M') + p.x + ' ' + p.y).join(' ');
    if (!measurePath){ measurePath = document.createElementNS('http://www.w3.org/2000/svg','path'); measurePath.setAttribute('class','measure-line'); overlay.appendChild(measurePath); }
    measurePath.setAttribute('d', d);

    const lenPx = totalPixels();
    const lenMeters = lenPx * getMetersPerPixel();
    let target = lenPx / 2; let acc = 0; let mid = {x: measurePoints[0].x, y: measurePoints[0].y};
    for (let i=1;i<measurePoints.length;i++){
      const a=measurePoints[i-1], b=measurePoints[i]; const seg = Math.hypot(b.x-a.x, b.y-a.y);
      if (acc + seg >= target){ const t = (target - acc) / seg; mid = { x: a.x + (b.x-a.x)*t, y: a.y + (b.y-a.y)*t }; break; }
      acc += seg;
    }
    if (!measureLabel){ measureLabel = document.createElementNS('http://www.w3.org/2000/svg','text'); measureLabel.setAttribute('class','measure-label'); overlay.appendChild(measureLabel); }
    measureLabel.setAttribute('x', mid.x);
    measureLabel.setAttribute('y', mid.y - 8);
    measureLabel.textContent = (lenMeters >= 1000) ? (lenMeters/1000).toFixed(2) + ' km' : Math.round(lenMeters) + ' m';
  }

  stage.addEventListener('click', e => {
    if (mode!=='measure') return;
    const rect=stage.getBoundingClientRect();
    const wx = (e.clientX - rect.left - tx) / scale; const wy = (e.clientY - rect.top - ty) / scale;
    measurePoints.push({x:wx,y:wy}); updateMeasurePath();
  });

  // ===== Skallinje =====
  const SCALE_CANDIDATES = [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000];
  const metersToScreenPx = m => (m / getMetersPerPixel()) * scale;
  function updateScaleBar(){ const targetMin = 80, targetMax = 220; let best = SCALE_CANDIDATES[0]; let bestPx = metersToScreenPx(best); for (const m of SCALE_CANDIDATES){ const px = metersToScreenPx(m); if (px >= targetMin && px <= targetMax){ best = m; bestPx = px; break; } if (Math.abs(px - targetMin) < Math.abs(bestPx - targetMin)){ best = m; bestPx = px; } } sbBar.style.width = Math.max(10, Math.round(bestPx)) + 'px'; sbLabel.textContent = (best < 1000) ? (best + ' m') : ((best/1000) + ' km'); }

  // ===== Helpers för export =====
  function dataURLtoImage(dataURL){ return new Promise((resolve, reject) => { const img=new Image(); img.onload=()=>resolve(img); img.onerror=reject; img.decoding='async'; img.src=dataURL; }); }
  function canvasToBlob(canvas, mime, quality){ return new Promise((resolve) => { if (canvas.toBlob){ canvas.toBlob(b => resolve(b), mime, quality); } else { // old fallback
      const data = canvas.toDataURL(mime, quality); const bin = atob(data.split(',')[1]); const arr = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); resolve(new Blob([arr], {type:mime})); }
  }); }
  async function imageToWebPBlob(dataURL){ // skala + konvertera → WebP (fallback JPEG)
    const img = await dataURLtoImage(dataURL);
    let { width:w, height:h } = img;
    const scale = Math.min(1, MAX_IMG_EDGE / Math.max(w,h));
    if (scale < 1){ w = Math.round(w*scale); h = Math.round(h*scale); }
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
    let blob = await canvasToBlob(c, 'image/webp', WEBP_QUALITY);
    if (!blob || blob.size === 0){ // Safari <14 fallback
      blob = await canvasToBlob(c, 'image/jpeg', 0.85);
    }
    return blob;
  }
  async function sha1Hex(buffer){ const hash = await crypto.subtle.digest('SHA-1', buffer); const b = new Uint8Array(hash); return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join(''); }

  function parseHTML(html){ const div = document.createElement('div'); div.innerHTML = html; return div; }

  // Gå igenom en notis-HTML: extrahera data:-bilder → images/<hash>.webp
  async function processNoteHTML(html, zipImages, seen){
    const root = parseHTML(html);
    const imgs = Array.from(root.querySelectorAll('img'));
    for (const img of imgs){
      const src = img.getAttribute('src') || '';
      if (!src.startsWith('data:image/')) continue; // redan extern bild
      const blob = await imageToWebPBlob(src);
      const arr = await blob.arrayBuffer();
      const hash = await sha1Hex(arr);
      const ext = (blob.type === 'image/webp') ? 'webp' : (blob.type === 'image/jpeg' ? 'jpg' : 'bin');
      const filename = `images/${hash}.${ext}`;
      if (!seen.has(hash)){ seen.add(hash); zipImages.file(`${hash}.${ext}`, new Uint8Array(arr)); }
      img.setAttribute('src', filename); // ersätt i HTML
      // ta bort eventuella width/height som låser layout felaktigt
      img.removeAttribute('width'); img.removeAttribute('height');
    }
    return root.innerHTML;
  }

  // ===== Export (ZIP: data.json + images/*) =====
  async function exportZip(){
    try {
      await openDB();
      const meta = JSON.parse(localStorage.getItem(LSK) || '[]');
      const htmls = await idbBulkGet(meta.map(m => m.id));
      const htmlById = {}; htmls.forEach(({id, html}) => { htmlById[id] = html || ''; });

      const zip = new JSZip();
      const imagesFolder = zip.folder('images');
      const seen = new Set();
      const outMarkers = [];

      // Processa varje notis: extrahera dataURL‑bilder → images/*, uppdatera HTML
      for (const m of meta){
        const originalHTML = htmlById[m.id] || '';
        const processedHTML = await processNoteHTML(originalHTML, imagesFolder, seen);
        outMarkers.push({ id: m.id, x: m.x, y: m.y, html: processedHTML });
      }

      const payload = {
        exportedAt: new Date().toISOString(),
        metersPerPixel: getMetersPerPixel(),
        markers: outMarkers
      };

      zip.file('data.json', JSON.stringify(payload, null, 2));

      const blob = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'export.zip';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    } catch(err){ console.error(err); alert('Export misslyckades: ' + err.message); }
  }

  btnExport.addEventListener('click', () => { if (IS_PLAYER) return; exportZip(); });

  // ===== Init =====
  async function init(){
    imgW = map.naturalWidth; imgH = map.naturalHeight; await openDB();
    if (IS_PLAYER){ btnExport.style.display = 'none'; await loadAllFromJSON(); pasteHint.style.display = 'none'; editorBtns.style.display = 'none'; sheetHint.style.display = 'none'; }
    else { await loadAllFromLocal(); }
    fitToScreenAndCenter(); clampPan(); applyTransform(); bindOnce(); updateScaleBar();
  }
  if (map.complete && map.naturalWidth) init(); else map.onload = init;
  window.addEventListener('resize', () => { clampPan(); applyTransform(); updateScaleBar(); });
})();
</script>
</body>
</html>
